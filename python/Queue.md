## Queue 

삽입의 삭제의 위치가 제한적인 자료구조

큐의 뒤에서는 삽입만, 앞에서는 삭제만 이루어진다.

선입선출구조(FIFO)

큐에 삽입된 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.



연산

enQueue() : 큐의 뒤쪽에 원소를 삽입하는 연산

deQueue() : 큐의 앞쪽에서 원소를 삭제하고 반환하는 연산

createQueue() : 공백 상태의 큐를 생성하는 연산

isEmpty() : 큐가 공백상태인지 확인하는 연산

isFull() : 큐가 포화상태인지 확인하는 연산

Qpeek() : 큐의 앞쪽에서 원소를 삭제없이 반환하는 연산



선형 큐

- 1차원 배열을 이용한 큐
- 큐의 크기 = 배열의 크기
- front : 저장된 첫번째 원소의 인덱스
- rear : 저장된 마지막 원소의 인덱스

상태 표현

- 초기 상태 : front = rear = -1
- 공백상태 front = rear
- 포화상태 rear = n-1

삽입 : enqueue

- 마지막 원소 뒤에 새로운 원소를 삽입하기 위해 rear 값을 하나 증가시켜 새로운 원소를 삽입할 자리를 마련
- 그 인덱스에 해당하는 배열 원소에 item을 저장

```
def enQueue(item):
global rear
if isFull() : print("Queue_full")
else:
	rear<- rear +1;
	Q[rear] <-item;
```



초기 공백 상태

- front = rear = 0
- front 와 rear의 위치가 배열의 마지막 인덱스인 n-1를 가리킨 후, 그 다음에는 순환을 이루어 배열의 처음 인덱스인0으로 이동해야 함
- 이를 위해 나머지 연산자 mod를 사용함

front 변수

- 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front 가 있는 자리는 사용하지 않고 항상 빈자리로 둠

삽입 및 삭제 위치

선형큐 : rear = rear+1 / front = front +1

원형 큐 : rear = (rear+1) mod n / front = (front+1) mod n

---

### BFS

너비우선 탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 차례대로 방문한 후에 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례대로 방문하는 방식



인접한 정점들에 대해 탐색한 후 차례로 다시 너비 우선탐색을 진행해야 하므로 선입 선출 형태의 자료구조인 큐를 활용





```
```

