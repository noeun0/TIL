# 깊이 우선 탐색 Depth-First Search

> 맹목적 탐색 방법의 하나로, 탐색 트리의 최근 첨가된 노드를 선택하고, 이 노드에 적용 가능한 동작자 중 하나를 적용하여 트리에 다음 수준의 한개의 자식 노드를 첨가하며, 첨가된 자식 노드가 목표 노드일 때 까지 앞의 자식 노드의 첨가 과정을 반복해 가는 방식이다. 대표적으로 **백트래킹에 사용**된다. 일반적으로 **재귀호출을 사용하여 구현하지만, 단순한 스택 배열로 구현하기도 한다**. 구조상 스택 오버플로우를 유의해야한다.



- 갈림길이 나타날 때마다 다른 길이 있다는 정보만 기록하면서 자신이 지나간 길을 지워나간다. 그러다 막다른 곳에 도달하면 직전 갈림길 까지 돌아가면서 이길은 아님 이라는 표식을 남긴다. 그렇게 갈림길을 순차적으로 탐색해 나가다 목적지를 발견하면 그대로 해답을 내고 종료.
- 단순 검색 속도 자체는 **BFS에 비해서 느리다**. 하지만 검색이 아닌 트래버스를 할 경우는 많이 쓰인다. DFS는 특히 리프 노드에만 데이터를 저장하는 **정렬 트리 구조에서 항상 순서대로 데이터를 방문한다는 장점이 있다**. **백트래킹에 사용되는 이유도 공동 상위를 가지는 아래 리프 노드들을 한방에 잘라 내 버리는게 가능하기 때문이다.**

#### 장점

- 단지 현 경로상의 노드들만을 기억하게 되므로 **저장공간의 수요가 비교적 적다**.
- 목표노드가 **깊은 단계에 있을 경우 해를 빨리 구할 수 있다**.

#### 단점

- **해가 없는 경로에 깊이 빠질 가능성이 있다**. 따라서 실제의 경우 미리 지정한 임의의 깊이 까지만 탐색하고 목표노드를 발견하지 못하면 다음의 경로를 따라 탐색하는 방법이 유용할 수 있다.
- **얻어진 해가 최단 경로가 된다는 보장이 없다.** 이는 목표에 이르는 경로가 다수인 문제에 대해 깊이 우선 탐색은 해에 다다르면 탐색을 끝내버리므로 이때 얻어진 해는 최적이 아닐 수 도 있다는 의미이다.

#### 특징

- **자기자신을 순환하는 순환 알고리즘**의 형태를 가지고 있다.
- 전위 순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류이다.
- 이 알고리즘을 구현할 때 가장 큰 차이점은, 그래프 탐색의 경우 **어떤 노드를 방문 했었는지 여부를 반드시 검사**해야 한다는 것이다. - 이를 검사하지 않으면 무한루프에 빠질 위험이 있다.



### ✨ 구현하기

**로직**

- 탐색 시작 노드를 시작점으로 방문 처리를 한다
- 시작 노드의 인접 노드에 방문하지 않은 노드가 있으면 그 노드를 방문하고 방문처리를 한다. 방문처리한다. 방문처리가 없다면 그 전단계 노드로 간다
- 위 과정을 더 이상 수행할 수 없을때까지 반복

**구현**

1. 구현 방법은 두가지가 있다. **스택**을 이용하거나, **재귀**를 이용하거나!

2. 방문 처리도 방법이 크게 두가지로 나뉜다.

   - 노드와, 거리를 주어주는 문제라면:  방문 했는지 확인하는 **리스트**를 하나 만들어서 방문했는지 확인하면서 진행

     (리스트를 만드는 방법도 두개로 나뉜다)

     1. 인접 행렬 방식

        : 2차원 배열을 사용. 인덱스 값을 활용한다. 모든 관계를 저장하는 방식. 노드 개수가 많을 수록 메모리가 불필요하게 낭비. 하지만 특정 두 노드가 연결되어있는지에 대한 정보는 빠르게 얻을 수 있다.

     ```python
     graph = [
     	[0,7,5],
     	[7,0,inf],
     	[5,inf,0]
     ]
     
     # v에 연결된 노드 탐색할때
     for i in range(len(graph[v])):
     	if graph[v][i] !=0: # 0이 아니면 연결된 것
     	if not visited[i]:
     		dfs(graph,i,visited)
     ```

     1. 인접 리스트 방식

        : 연결된 정보만을 저장. 메모리를 효율적으로 사용. 그러나 특정 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다. 모든 인접노드를 순회하는 경우라면 메모리 공간의 낭비를 줄일 수 있다.

     ```python
     [[(1,7), (2,5)] # 노드 0에 연결된 노드 정보
     [(0,7), (4,5) , (6,2)] # 노드 1에 저장된 노드 정보
     ...
     ]
     # (노드, 거리)
     
     # v에 연결된 노드 탐색할때
     for i in graph[v]:
     	if not visited[i]:
     		dfs(graph,i,visited)
     ```

   - 경로를 2차원 리스트로 주어줬을때

     : 방문한 곳 **값을 바꿔주며** 방문했다고 처리하며 진행

     다시 사용할려면 딥카피를 써야한다는 단점....

     노드 개념이 아니라 이동할 부분이 리스트상에서 상하좌우  연결 되어있을때 사용