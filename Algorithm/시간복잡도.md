# 시간복잡도

### Big - O 표기법

> - 알고리즘의 성능을 수학적으로 표현
> - 알고리즘의 시간, 공간 복잡도를 표현
> - 알고리즘의 실제 러닝타임 계산이 아닌 데이터나 사용자의 증가에 따른 알고리즘 성능의 예측을 위한 것
> - 빅오표기법은 상수는 고정된 숫자이므로 데이터의 증가에 영향을 받지 않으므로 과감히 생략한다.





**O(1)**

- 데이터의 양에 상관 없이 언제나 일정한 속도로 결과를 반환 하는 것

- 데이터가 증가함에 따라 성능의 차이가 없음

  

**O(n)**

- 입력 데이터의 크기에 비례해서 처리 시간이 걸리는 알고리즘

- 데이터가 증가함에 따라 비례해서 처리시간이 같은 비율로 증가한다.

- 우상향 그래프를 나타냄

  

**O(n^2)**

- n*n 한 변의 길이가 n인 정사각형 면적만큼 반복하는 알고리즘

- 데이터가 증가함에 따라 처리시간이 점점 급격하게 증가한다

  

**O(nm)**

- n*m 각각 변이 n,m인 직사각형의 면적만큼 반복하는 알고리즘

  

**O(n*3)**

- n* n* n 즉 한 변의 길이가 n인 정육면체 부피만큼 반복하는 알고리즘
- n* n보다 데이터가 증가함에 따라 더 급격하게 증가한다

- n크기의 반복문을 3중으로 돌릴 수 있다.

  

**O(2^n)**

- 피보나치 수열 처럼 함수를 호출하면 재귀적으로 두번 자신을 호출하는 알고리즘

- 트리의 높이만큼 2번씩 진행됨으로 2*N승 만큼 반복된다

- 데이터의 증가에 따라 가장 급격하게 상승하기 때문에, 재귀함수는 시간복잡도를 생각했을때 지양하는 것이 좋을 것 같다.

  

**O(m*n)**

- m번씩 n 번 반복되는 알고리즘



**O(log n)**

- 진행됨에 따라 다루는 데이터 양이 반씩 줄어드는 알고리즘

- O(n)보다도 시간 복잡도가 낮다

- 데이터가 증가해도 성능이 크게 다르지 않다.

  

**O(sqrt(n))**

- n*n 크기의 알고리즘에서 한 반복 즉 n번만 진행되는 알고리즘



